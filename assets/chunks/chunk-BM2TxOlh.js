import{jU as R,jV as E,jW as U,jX as k,bu as q,bx as F,bo as W,bq as A,br as M,e7 as Z,aj as X,ak as Y,ev as B,am as $,z as y,eX as J,ar as K,di as Q,b0 as P,aH as j,jY as ee,jZ as te,eZ as H,fw as ae,ef as ie,eg as re,j_ as D,bI as C,j$ as O,k0 as se,fn as N,il as ne,k1 as v,k2 as oe,k3 as le,bH as he,a1 as f,a2 as x,a4 as de,bF as ue}from"./chunk-CMhy9c9G.js";import{l as ce}from"./chunk-CgSr3-7H.js";import{r as ge}from"./chunk-CS1tf3PV.js";import{I as me}from"./chunk-DmemvuQy.js";function pe(t,e,a){const r=R(t)/E(t),i={width:a,height:a};return r>1.0001?i.height=a/r:r<.9999&&(i.width=a*r),i.width=Math.round(i.width/(R(t)/R(e))),i.height=Math.round(i.height/(E(t)/E(e))),i}function z(t,e){return U(t,[[e[0],e[1],-1],[e[2],e[1],-1],[e[2],e[3],-1],[e[0],e[3],-1]])}function fe(t,e,a){if(!k(e,a))return z(t,a);const r=[e[1]-a[1],Math.min(e[3],a[3])-Math.max(e[1],a[1]),a[3]-e[3],123456],i=[e[0]-a[0],Math.min(e[2],a[2])-Math.max(e[0],a[0]),a[2]-e[2],123456],o=a[2]-a[0],l=a[3]-a[1],s=i[0]>0&&i[2]>0?3:2,h=r[0]>0&&r[2]>0?3:2,n=(h+1)*(s+1),u=q(3*n),c=F(2*n),d=new Array(6*(h*s-1));let b=0,I=0,G=0,m=0,p=0;for(let w=0;w<4;w++){const T=r[w];if(T<=0)continue;let S=0;for(let _=0;_<4;_++){const L=i[_];L<=0||(u[I++]=a[0]+S,u[I++]=a[1]+b,u[I++]=-1,c[G++]=S/o,c[G++]=b/l,_<3&&w<3&&(_!==1||w!==1)&&(d[p++]=m,d[p++]=m+1,d[p++]=m+s+1,d[p++]=m+1,d[p++]=m+s+2,d[p++]=m+s+1),m++,S+=L)}b+=T}const V=new Array(d.length);return new W(t,[[A.POSITION,new M(u,d,3,!0)],[A.NORMAL,new M(we,V,3,!0)],[A.UV0,new M(c,d,2,!0)]])}const we=[0,0,1];let g=class extends Z(ce(ue)){constructor(){super(...arguments),this.drapeSourceType=X.RasterImage,this.updatePolicy=Y.SYNC,this.fullExtentInLocalViewSpatialReference=null,this.maximumDataResolution=null,this._images=new Array,this._extents=new Array,this._overlays=new Array,this.updateWhenStationary=!0,this._drapeSourceRenderer=null,this.refreshDebounced=B(async t=>{this.destroyed||await this._doRefresh(t).catch(e=>{$(e)||y.getLogger(this).error(e)})},2e3)}get visibleAtCurrentScale(){const t=this.layer,e="effectiveScaleRange"in t?t.effectiveScaleRange:null;return J(e,this.view.scale)}initialize(){this._drapeSourceRenderer=this.view.basemapTerrain.overlayManager.registerGeometryDrapeSource(this),this.addHandles(K(()=>this.view.basemapTerrain.overlayManager.unregisterDrapeSource(this))),this.addResolvingPromise(ge(this).then(t=>this._set("fullExtentInLocalViewSpatialReference",t))),this._updatingHandles.add(()=>this.suspended,()=>this._suspendedChangeHandler())}destroy(){this.clear()}setDrapingExtent(t,e){this._spatialReference=e,t.forEach((a,r)=>{this._overlays[r]=a,this._updateImageExtent(a,r)})}_updateImageExtent(t,e){const a=this._clippedExtent(t.extent,_e);if(a==null)return;const r=pe(t.extent,a,t.resolution);let i=t.pixelRatio*this.view.state.pixelRatio;const{layer:o}=this;if("imageMaxWidth"in o&&o.imageMaxWidth!=null||"imageMaxHeight"in o&&o.imageMaxHeight!=null){const s=o.imageMaxWidth,h=o.imageMaxHeight;if(r.width>s){const n=s/r.width;r.height=Math.floor(r.height*n),r.width=s,i*=n}if(r.height>h){const n=h/r.height;r.width=Math.floor(r.width*n),r.height=h,i*=n}}const l=this._extents[e];l&&Q(l.extent,a)&&this._imageSizeEquals(a,l.imageSize,r)||(this._extents[e]={extent:P(a),imageSize:r,pixelRatio:i},this.suspended||this._fetch(e).catch(s=>{$(s)||y.getLogger(this).error(s)}))}clear(){for(let t=0;t<this._images.length;t++)this._clearImage(t)}async doRefresh(){return this._doRefresh()}async _doRefresh(t){if(this.suspended)return;const e=[];for(let a=0;a<this._extents.length;a++)this._extents[a]&&e.push(this._fetch(a,t));await Promise.allSettled(e)}async processResult(t,e,a){(e instanceof HTMLImageElement||e instanceof HTMLCanvasElement)&&(t.image=e)}findExtentInfoAt(t){for(const e of this._extents){const a=e.extent;if(new j(a[0],a[1],a[2],a[3],this._spatialReference).contains(t))return e}return null}getFetchOptions(){}async redraw(t,e){await ee(this._images,async(a,r)=>{a&&(await t(a,e),await this._createStageObjects(r,a.image,e))})}_imageSizeEquals(t,e,a){if(!this.maximumDataResolution)return!1;const r=R(t)/this.maximumDataResolution.x,i=E(t)/this.maximumDataResolution.y,o=r/e.width,l=i/e.height,s=r/a.width,h=i/a.height,n=Math.abs(o-s),u=Math.abs(l-h),c=te.TESTS_DISABLE_OPTIMIZATIONS?0:1.5;return n<=c&&u<=c}async _fetch(t,e){if(this.suspended)return;const a=this._extents[t],r=a.extent;this._images[t]||(this._images[t]={texture:null,material:null,renderGeometry:null,loadingPromise:null,loadingAbortController:null,image:null,pixelData:null,renderExtent:P(r)});const i=this._images[t];i.loadingAbortController=H(i.loadingAbortController);const o=new j(r[0],r[1],r[2],r[3],this._spatialReference);if(o.width===0||o.height===0)return void this._clearImage(t);const l=new AbortController;i.loadingAbortController=l,ae(e,()=>l.abort());const s=l.signal,h=this._waitFetchReady(s).then(async()=>{const n={requestAsImageElement:!0,pixelRatio:this._overlays[t].pixelRatio,...this.getFetchOptions(),signal:s},{height:u,width:c}=a.imageSize;return this.layer.fetchImage(o,c,u,n)}).then(n=>{if(ie(s))throw y.getLogger(this).warnOnce("A call to fetchImage resolved even though the request was aborted. fetchImage should not resolve if options.signal.aborted is true."),re();return this.processResult(i,n)}).then(()=>{D(i.renderExtent,r)});i.loadingPromise=h,await this._updatingHandles.addPromise(h.then(async()=>{C(s),await this._createStageObjects(t,i.image,s)}).catch(n=>{throw n&&!$(n)&&y.getLogger(this).error(n),n}).finally(()=>{h===i.loadingPromise&&(i.loadingPromise=null,i.loadingAbortController=null)}))}_clearImage(t){const e=this._images[t];if(e){e.renderGeometry!=null&&(this._drapeSourceRenderer.removeGeometries([e.renderGeometry],O.UPDATE),e.renderGeometry=null);const a=this.view._stage,r=e.texture;r?.unload(),a.remove(r),e.texture=null,a.remove(e.material),e.material=null,e.loadingAbortController=H(e.loadingAbortController),e.loadingPromise=null,e.image=null,e.pixelData=null}}async _createStageObjects(t,e,a){const r=this.view._stage,i=this._images[t],o=()=>{i.texture?.unload(),r.remove(i.texture),i.texture=null,i.renderGeometry&&(this._drapeSourceRenderer.removeGeometries([i.renderGeometry],O.UPDATE),i.renderGeometry=null)};if(e){const l=new se(e,{width:e.width,height:e.height,preMultiplyAlpha:!0,wrap:{s:N.CLAMP_TO_EDGE,t:N.CLAMP_TO_EDGE}});let s;if(await ne(this._images[t===v.INNER?v.OUTER:v.INNER].loadingPromise),C(a),o(),await r.schedule(()=>l.load(r.renderView.renderingContext),a),r.add(l),i.texture=l,i.material==null?(i.material=new me({textureId:l.id}),r.add(i.material)):i.material.setParameters({textureId:l.id}),t===v.INNER)s=z(i.material,i.renderExtent);else{const h=this._images[0].renderExtent;if(!h)return void o();s=fe(i.material,h,i.renderExtent)}i.renderGeometry=new oe(s),i.renderGeometry.localOrigin=this._overlays[t].renderLocalOrigin,this._drapeSourceRenderer.addGeometries([i.renderGeometry],O.UPDATE)}else o(),r.remove(i.material),i.material=null}_clippedExtent(t,e){if(this.view.viewingMode!=="local")return D(e,t);const a=this.view.basemapTerrain;return a.ready?le(t,a.extent,e):D(e,t)}_suspendedChangeHandler(){this.suspended?this.clear():this.refreshDebounced()}async _waitFetchReady(t){await he(()=>this.view.stationary,t),C(t)}};f([x()],g.prototype,"layer",void 0),f([x()],g.prototype,"suspended",void 0),f([x({readOnly:!0})],g.prototype,"fullExtentInLocalViewSpatialReference",void 0),f([x({readOnly:!0})],g.prototype,"visibleAtCurrentScale",null),f([x()],g.prototype,"updating",void 0),g=f([de("esri.views.3d.layers.DynamicLayerView3D")],g);const Ee=g,_e=P();export{Ee as N};
