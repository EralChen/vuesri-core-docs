import{b as E,c as _,d as k,e as G,j as f,q,l as g,k as b,u as $,m as p,L as z,s as u,n as I}from"./chunk-CGsGeN7j.js";import{$ as B,w as x,I as N,v as O,j as C,y as V,P as H,l as F,d as Q,c as T}from"./chunk-CqRmJ70k.js";import{t as W}from"./chunk-Ckdf8AEO.js";import"./chunk-ByM7454y.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-D73HSFae.js";const h="Feature Service",w="feature-layer-utils",X=`${w}-save`,Z=`${w}-save-as`,m=`${w}-saveall`,y=`${w}-saveall-as`;function v(r){return{isValid:z(r)&&(r.type!=="feature"||!r.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function J(r){const e=[],t=[];for(const{layer:a,layerJSON:s}of r)a.isTable?t.push(s):e.push(s);return{layers:e,tables:t}}function M(r){return J([r])}async function R(r,e){return/\/\d+\/?$/.test(r.url)?M(e[0]):D(e,r)}async function D(r,e){if(r.reverse(),!e)return J(r);const t=await rr(e,r);for(const a of r)U(a.layer,a.layerJSON,t);return ar(t,r),t}async function rr(r,e){let t=await r.fetchData("json");if(er(t))return t;t||={},tr(t);const{layer:{url:a,customParameters:s,apiKey:n}}=e[0];return await or(t,{url:a??"",customParameters:s,apiKey:n},e.map(o=>o.layer.layerId)),t}function er(r){return!!(r&&Array.isArray(r.layers)&&Array.isArray(r.tables))}function tr(r){r.layers||=[],r.tables||=[]}function ar(r,e){const t=[],a=[];for(const{layer:s}of e){const{isTable:n,layerId:o}=s;n?a.push(o):t.push(o)}A(r.layers,t),A(r.tables,a)}function A(r,e){if(r.length<2)return;const t=[];for(const{id:a}of r)t.push(a);_(t.sort(L),e.slice().sort(L))&&r.sort((a,s)=>{const n=e.indexOf(a.id),o=e.indexOf(s.id);return n<o?-1:n>o?1:0})}function L(r,e){return r<e?-1:r>e?1:0}async function or(r,e,t){const{url:a,customParameters:s,apiKey:n}=e,{serviceJSON:o,layersJSON:i}=await W(a,{customParameters:s,apiKey:n}),l=P(r.layers,o.layers,t),c=P(r.tables,o.tables,t);r.layers=l.itemResources,r.tables=c.itemResources;const d=[...l.added,...c.added],Y=i?[...i.layers,...i.tables]:[];await nr(r,d,a,Y)}function P(r,e,t){const a=k(r,e,(n,o)=>n.id===o.id);r=r.filter(n=>!a.removed.some(o=>o.id===n.id));const s=a.added;return s.forEach(({id:n})=>{r.push({id:n})}),{itemResources:r,added:s.filter(({id:n})=>!t.includes(n))}}async function nr(r,e,t,a){const s=await sr(e),n=e.map(({id:o,type:i})=>new(s.get(i))({url:t,layerId:o,sourceJSON:a.find(({id:l})=>l===o)}));await Promise.allSettled(n.map(o=>o.load())),n.forEach(o=>{const{layerId:i,loaded:l,defaultPopupTemplate:c}=o;if(!l||c==null)return;const d={id:i,popupInfo:c.toJSON()};o.operationalLayerType!=="ArcGISFeatureLayer"&&(d.layerType=o.operationalLayerType),U(o,d,r)})}async function sr(r){const e=[];r.forEach(({type:s})=>{const n=ir(s),o=G[n];e.push(o())});const t=await Promise.all(e),a=new Map;return r.forEach(({type:s},n)=>{a.set(s,t[n])}),a}function ir(r){let e;switch(r){case"Feature Layer":case"Table":e="FeatureLayer";break;case"Oriented Imagery Layer":e="OrientedImageryLayer";break;case"Catalog Layer":e="CatalogLayer"}return e}function U(r,e,t){r.isTable?S(t.tables,e):S(t.layers,e)}function S(r,e){const t=r.findIndex(({id:a})=>a===e.id);t===-1?r.push(e):r[t]=e}function j(r,e){if(!r.length)throw new u(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function lr(r,e){const t=r.map(a=>a.portalItem.id);if(new Set(t).size>1)throw new u(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function K(r,e){const t=r.map(a=>a.layerId);if(new Set(t).size!==t.length)throw new u(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function cr(r){j(r,m),await Promise.all(r.map(e=>e.load()));for(const e of r)F(e,m,v),Q({layer:e,itemType:h,errorNamePrefix:m});lr(r,m),K(r,m)}async function pr(r,e){const{url:t,layerId:a,title:s,fullExtent:n,isTable:o}=r,i=f(t);e.url=i?.serverType==="FeatureServer"?t:`${t}/${a}`,e.title||=s,e.extent=null,o||n==null||(e.extent=await g(n)),b(e,p.METADATA),b(e,p.MULTI_LAYER),I(e,p.SINGLE_LAYER),o&&I(e,p.TABLE)}function ur(r,e){for(const n of r){const o=n.parsedUrl.path,i=f(o);if(!i?.url.path)throw new u(`${e}:invalid-parameters`,T(n,`has unsupported url pattern: ${o}`),{layer:n});const c=i?.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${e}:invalid-parameters`,T(n,`has unsupported server type: ${c}`),{layer:n});if(c==="MapServer"&&r.length>1)throw new u(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=f(r[0].parsedUrl.path),a=t?.url.path;if(!r.every(n=>f(n.parsedUrl.path)?.url.path===a))throw new u(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function mr(r){j(r,y),await Promise.all(r.map(e=>e.load()));for(const e of r)F(e,y,v);ur(r,y),K(r,y)}async function yr(r,e){let t=0,a=0;for(const{isTable:o}of e)o?a++:t++;const s=e[0].parsedUrl.path,n=f(s);if(r.url=n?.serverType==="FeatureServer"?n.url.path:s,r.title||=n.title,r.extent=null,t>0){const o=e.map(i=>i.fullExtent).filter(q).reduce((i,l)=>i.clone().union(l));o&&(r.extent=await g(o))}b(r,p.METADATA),$(r,p.MULTI_LAYER,e.length>1),$(r,p.SINGLE_LAYER,e.length===1),$(r,p.TABLE,a>0&&t===0),O(r)}async function Wr(r,e){return B({layer:r,itemType:h,validateLayer:v,createItemData:(t,a)=>R(a,[t]),errorNamePrefix:X},e)}async function Xr(r,e){await cr(r);const t=r[0].portalItem,a=x(t),s=await Promise.all(r.map(o=>N(o,a,e))),n=await R(t,r.map((o,i)=>({layer:o,layerJSON:s[i]})));return O(t),await t.update({data:n}),await Promise.all(r.slice(1).map(o=>o.portalItem.reload())),E(a),t.clone()}async function Zr(r,e,t){return C({layer:r,itemType:h,validateLayer:v,createItemData:(a,s)=>Promise.resolve(M(a)),errorNamePrefix:Z,newItem:e,setItemProperties:pr},t)}async function re(r,e,t){await mr(r);const a=V({itemType:h,errorNamePrefix:y,newItem:e}),s=x(a),n=await Promise.all(r.map(i=>N(i,s,t))),o=await D(r.map((i,l)=>({layer:i,layerJSON:n[l]})));await yr(a,r),await H(a,o,t);for(const i of r)i.portalItem=a.clone();return E(s),a}export{Wr as save,Xr as saveAll,re as saveAllAs,Zr as saveAs};
