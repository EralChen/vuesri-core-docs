import{a1 as o,a2 as p,a4 as h,A as l,mE as m,eo as g,en as x,mF as y,mG as F}from"./chunk-YzRi88Dj.js";import{x as D}from"./chunk-DezwSTMY.js";import{t as w}from"./chunk-Disbo7-V.js";const $="updating";function A(n){return n==="updating"?null:n}function v(n){return n==="updating"}const I=n=>{let r=class extends n{constructor(){super(...arguments),this._definitionExpressionErrors=0,this._maxDefinitionExpressionErrors=20,this.logError=t=>{this._definitionExpressionErrors<this._maxDefinitionExpressionErrors&&l.getLogger(this).error("Error while evaluating definitionExpression: "+t),this._definitionExpressionErrors++,this._definitionExpressionErrors===this._maxDefinitionExpressionErrors&&l.getLogger(this).error("Further errors are ignored")}}get parsedDefinitionExpression(){if(!this.i3slayer?.definitionExpression)return null;try{const t=D.create(this.i3slayer.definitionExpression,this.i3slayer.fieldsIndex);if(!t.isStandardized)return l.getLogger(this).error("definitionExpression is using non standard function"),null;const e=[],i=t.fieldNames;return m(i,this.i3slayer.fields,{missingFields:e}),e.length>0?(l.getLogger(this).error(`definitionExpression references unknown fields: ${e.join(", ")}`),null):(this._definitionExpressionErrors=0,t)}catch(t){return l.getLogger(this).error("Failed to parse definitionExpression: "+t),null}}get definitionExpressionFields(){return this.parsedDefinitionExpression?this.parsedDefinitionExpression.fieldNames:[]}_evaluateClause(t,e){try{return t.testFeature(e)}catch(i){return this.logError(i),!1}}_addDefinitionExpressionToQuery(t){if(!this.parsedDefinitionExpression)return t;const e=this.i3slayer.definitionExpression,i=t.clone();return i.where?i.where=`(${e}) AND (${i.where})`:i.where=e,i}};return o([p({readOnly:!0})],r.prototype,"parsedDefinitionExpression",null),o([p({readOnly:!0})],r.prototype,"definitionExpressionFields",null),r=o([h("esri.views.3d.layers.support.DefinitionExpressionSceneLayerView")],r),r},N=n=>{let r=class extends n{constructor(){super(...arguments),this.timeExtent=null}get mergedFilter(){const{filter:t,timeExtent:e}=this;if(e==null)return t;const i=t?.clone()??new x;return e!=null&&(i.timeExtent=i.timeExtent?.intersection(e)??e),i}getTimeFilterDependencies(){const{timeInfo:t}=this.i3slayer;if(t==null)return[];const{startField:e,endField:i}=t;return[e,i]}addTimeFilter(t,e){if(e==null)return;const{timeInfo:i}=this.i3slayer;if(i==null)return;const{startField:f,endField:s,useTime:u}=i;if(!u||f==null&&s==null)return;const a=i.toJSON(),d=e.toJSON();t.push((c,E)=>this._timeFilter(c,E,a,d))}_timeFilter(t,e,i,f){const s=e.attributeInfo?.attributeData;if(s==null)return;const{startTimeField:u,endTimeField:a}=i;if(u!=null&&s[u]==null||a!=null&&s[a]==null)return;const d=w(i,f,new _(s));if(d==null)return;const{featureIds:c}=e;y(t,c,d)}};return o([p(g)],r.prototype,"timeExtent",void 0),o([p()],r.prototype,"mergedFilter",null),r=o([h("esri.views.3d.layers.support.TemporalSceneLayerView")],r),r};class _{constructor(r){this.attributeData=r}getAttribute(r,t){return F(this.attributeData[t],r)}getAttributeAsTimestamp(r,t){const e=this.getAttribute(r,t);return typeof e=="string"?new Date(e).getTime():typeof e=="number"||e==null?e:null}}export{A as a,v as b,$ as n,I as t,N as u};
