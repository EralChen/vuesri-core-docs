import{V as $}from"./chunk-DjjaYBlz.js";import{gO as R,gK as V,lz as w,lE as E,gZ as G,gR as y,g_ as B,gW as O,qX as I,h1 as k,h0 as F,aX as l,a7 as p,aY as c,ad as v,lt as L,dq as M,aL as T,E as x,aH as j,a4 as H,lj as P,h3 as _,as as A,ie as q,a8 as D,gS as S,gV as N,gT as b,h9 as Z}from"./chunk-CMhy9c9G.js";import{p as U,a as W}from"./chunk-35-ZZMVr.js";import{_ as X,c as K}from"./chunk-B-RuJrXv.js";import{u as Y}from"./chunk-Ds9r7LkQ.js";import"./chunk-DHvBO4SR.js";import"./chunk-DobUN8tB.js";import"./chunk-Dc5RCiI0.js";import"./chunk-Ch0SDxT-.js";/* empty css              */import"./chunk-ByM7454y.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DAZPr-5t.js";import"./chunk-CNtoRp8i.js";const J={...U,defaultOptions:{type:Object,default:()=>({})},source:{type:Array,default:()=>[]}},Q={click:e=>e,pointerMove:e=>e,load:e=>e},ee=R({name:"VaCluster3dLayer",components:{VaLayerHitEvents:X},props:J,emits:Q,setup(e,{emit:t}){const i=Y(),s=i.map,r=K(t),o=new C({...e.defaultOptions});return V(()=>{o.source=e.source}),W(s,o,e),w("vaLayer",o),w("vaGraphicsLayer",o),w("vaCluster3dLayer",o),t("load",{view:i,layer:o}),{hitEmits:r}}});function te(e,t,i,s,r,o){const a=G("VaLayerHitEvents");return y(),B(F,null,[O(a,I(e.hitEmits),null,16),k(e.$slots,"default")],64)}const f=E(ee,[["render",te]]);new l({size:14,color:new p([0,0,0,.5]),outline:new c({color:new p([255,255,255,.5]),width:1})});new v({color:new p([255,255,255]),font:{size:10,family:"arial"},yoffset:-3});new v({color:new p([255,255,255]),font:{size:6,family:"arial"},yoffset:-2});const m=new L({defaultSymbol:new l({size:6,color:"#FF0000"}),field:"clusterCount"}),se=new l({size:22,outline:new c({color:[221,159,34,.8]}),color:[255,204,102,.8]}),re=new l({size:24,outline:new c({color:[82,163,204,.8]}),color:[102,204,255,.8]}),oe=new l({size:28,outline:new c({color:[41,163,41,.8]}),color:[51,204,51,.8]}),ie=new l({size:32,outline:new c({color:[200,52,59,.8]}),color:[250,65,74,.8]});m.addClassBreakInfo(0,19,se);m.addClassBreakInfo(20,150,re);m.addClassBreakInfo(151,1e3,oe);m.addClassBreakInfo(1001,1/0,ie);var ne=Object.defineProperty,ae=Object.getOwnPropertyDescriptor,le=(e,t,i,s)=>{for(var r=s>1?void 0:s?ae(t,i):t,o=e.length-1,a;o>=0;o--)(a=e[o])&&(r=(s?a(t,i,r):a(r))||r);return s&&r&&ne(t,i,r),r};let C=class extends M{constructor(e){super(e),this.view=null,this.handles=[],this.gridClusters=[],this.source=[],this.clusterRatio=75,this.clusterToScale=5e6,this.clusterMinCount=2,this.clusterRenderer=m;const t=this.on("layerview-create",i=>{this.onLayerviewCreate(i)});this.handles.push(t),this.source=e?.source||[],e?.clusterRatio&&(this.clusterRatio=e.clusterRatio),e?.clusterToScale&&(this.clusterToScale=e.clusterToScale),e?.clusterMinCount&&(this.clusterMinCount=e.clusterMinCount),e?.clusterRenderer&&(this.clusterRenderer=e.clusterRenderer)}onLayerviewCreate(e){if(!this.view){this.view=e.layerView.view;const t=this.view.watch("stationary",i=>{i&&this.draw()});this.handles.push(t),this.draw()}}draw(){if(!(!this.view||!this.source.length||!this.view.extent)){this.clear(),this.isClustered&&this.createClusterGrid();for(const e of this.source){const t=this.getPointFromGraphic(e);if(this.view.extent.expand(1.2).contains(t))if(this.isClustered)for(const s of this.gridClusters)s.extent.contains(t)&&(s.points.push(t),s.singles.push(e),s.x=s.points.reduce((r,o)=>r+o.x,0)/s.points.length,s.y=s.points.reduce((r,o)=>r+o.y,0)/s.points.length,s.clusterCount++);else this.createSingle(e)}if(this.isClustered)for(let e=0;e<this.gridClusters.length;e++){const t=this.gridClusters[e];if(t.clusterCount>=this.clusterMinCount)this.createCluster(t);else for(const i of t.singles)this.createSingle(i)}}}async createCluster(e){const t=new ce,i=new T({x:e.x,y:e.y,spatialReference:this.view?.spatialReference}),s={x:e.x,y:e.y,clusterCount:e.clusterCount,isCluster:!0,gridCluster:e};t.clusterGraphic=new x({geometry:i,attributes:s}),t.textGraphic=new x({geometry:i,attributes:s,symbol:new v({text:e.clusterCount.toString(),color:"#fff",font:{size:12},verticalAlignment:"middle"})});const r=await this.clusterRenderer.getClassBreakInfo(t.clusterGraphic);r&&(t.clusterGraphic.symbol=r.symbol),this.add(t.clusterGraphic),this.add(t.textGraphic)}createSingle(e){this.add(e)}createClusterGrid(){if(!this.view)throw new Error("view is not defined");const e=Math.round(this.view.width/this.clusterRatio),t=Math.round(this.view.height/this.clusterRatio),i=(this.view.extent.xmax-this.view.extent.xmin)/e,s=(this.view.extent.ymax-this.view.extent.ymin)/t;this.gridClusters=[];let r,o,a,d;for(let n=0;n<e;n++){r=this.view.extent.xmin+i*n,o=r+i;for(let u=0;u<t;u++){a=this.view.extent.ymin+s*u,d=a+s;const z=new j({xmin:r,ymin:a,xmax:o,ymax:d,spatialReference:this.view.spatialReference}),g=new ue;g.extent=z,this.gridClusters.push(g)}}}clear(){this.removeAll()}get isClustered(){return this.view?this.view.scale>this.clusterToScale:!1}getPointFromGraphic(e){return e.geometry.type==="polygon"?e.geometry.centroid:e.geometry.type==="polyline"?e.geometry.extent.center:e.geometry}dispose(){this.clear(),this.handles.forEach(e=>e.remove())}};C=le([H("vuesri.core.Cluster3DLayer")],C);class ce{}class ue{constructor(){this.clusterCount=0,this.points=[],this.singles=[],this.x=0,this.y=0}}f.install=e=>{e.component(f.name||"VaCluster3dLayer",f)};const h=new L({defaultSymbol:new l({size:6,color:"#FF0000"}),field:"clusterCount"}),me=new l({size:22,outline:new c({color:[221,159,34,.8]}),color:[255,204,102,.8]}),he=new l({size:24,outline:new c({color:[82,163,204,.8]}),color:[102,204,255,.8]}),de=new l({size:28,outline:new c({color:[41,163,41,.8]}),color:[51,204,51,.8]}),fe=new l({size:32,outline:new c({color:[200,52,59,.8]}),color:[250,65,74,.8]});h.addClassBreakInfo(0,5,me);h.addClassBreakInfo(5,10,he);h.addClassBreakInfo(10,20,de);h.addClassBreakInfo(20,1/0,fe);const pe="https://services.arcgis.com/V6ZHFr6zdgNZuVG0/arcgis/rest/services/US_National_Parks_Annual_Visitation/FeatureServer/0",at=R({__name:"basic",setup(e){const i={map:new P({basemap:"arcgis-imagery"})},s=_([]),r=_([]),o=new A;o.returnGeometry=!0,o.outFields=["*"],o.where="1=1",q(pe,o).then(n=>{n.features.forEach(u=>{u.symbol=new D({symbolLayers:[{type:"icon",size:16,material:{color:"rgba(0,191,255,0.8)"}}]})}),s.value=n.features,r.value=n.fields});const a={clusterRenderer:h,clusterRatio:100,clusterToScale:2e6,clusterMinCount:2},d=async n=>{const u=n.view;console.log("layer loaded",n.layer),await n.layer.when(),u.goTo(n.layer.fullExtent)};return(n,u)=>(y(),S(b($),{"default-options":i},{default:N(()=>[s.value.length?(y(),S(b(f),{key:0,source:s.value,"default-options":a,onLoad:d},null,8,["source"])):Z("",!0)]),_:1}))}});export{at as default};
