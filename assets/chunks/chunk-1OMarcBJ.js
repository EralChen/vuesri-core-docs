import{V as A}from"./chunk-Nl6L5Sha.js";import{V as P}from"./chunk-zPn7vAq8.js";import{V as U}from"./chunk-HbTg3DvT.js";import{R as W}from"./chunk-FEI8nmeL.js";import{V as J}from"./chunk-AIkMVrBB.js";import{s as b,ql as l,qm as _,qn as j,qo as F,qp as k,qq as M,qr as z,qs as Q,qt as Z,qu as f,a5 as q,qv as H,qw as K,qx as X,qy as O,qz as Y,qA as ee,gZ as ae,he as I,h8 as te,h0 as re,h1 as ne,h4 as y,h5 as x,h6 as h,ha as se,h2 as w,C as ie,bR as oe}from"./chunk-r79-UitW.js";import"./chunk-iXGO8X4T.js";import"./chunk-X1l1T6Lo.js";import"./chunk-B3AFDltd.js";import"./chunk-NxD5GeLy.js";import"./chunk-QlMQA5MY.js";import"./chunk-XNej7aTS.js";import"./chunk-VeTFGOxM.js";import"./chunk-Y0Vu1B5E.js";import"./chunk-ENCxAf3G.js";import"./chunk-c4b-Yaea.js";import"./chunk-CaitbKEY.js";import"./chunk-woU6z8Ei.js";import"./chunk-lYyaG9p-.js";import"./chunk-1e5GIKf6.js";import"./chunk-GaQCtJAj.js";import"./chunk-Qgrzwe6s.js";const le=Q;async function me(a){if(!a?.layer||!a.view)throw new b("heatmap-statistics:missing-parameters","'layer' and 'view' parameters are required");const e=[l.CSVLayer,l.FeatureLayer,l.GeoJSONLayer,l.OGCFeatureLayer,l.OrientedImageryLayer,l.WFSLayer],{layer:r,...s}=a,n=_(r,e);if(!n)throw new b("heatmap-statistics:invalid-parameters","'layer' must be one of these types: "+j(e).join(", "));const t={layerAdapter:n,...s};t.radius=t.radius==null?t.blurRadius==null?18:F(t.blurRadius):t.radius;const u=t.signal!=null?{signal:t.signal}:null;await n.load(u);const p=t.field,o=p?n.getField(p):null,i=await k({field:p}),m=M(n,i,"heatmap-statistics:invalid-parameters");if(m)throw m;if(o){const c=z(n,o,"heatmap-statistics:invalid-parameters",le);if(c)throw c}return t}async function ce(a){const{layerAdapter:e,...r}=await me(a);return e.heatmapStatistics(r)}const D=.01;async function ue(a){if(!a?.layer||!a.view)throw new b("heatmap-renderer:missing-parameters","'layer' and 'view' parameters are required");const e={...a,layer:a.layer,view:a.view};e.radius??=e.blurRadius==null?18:F(e.blurRadius),e.minRatio??=.01,e.maxRatio??=1,e.fadeRatio??=.2,e.fadeToTransparent??=!0;const r=[l.CSVLayer,l.FeatureLayer,l.GeoJSONLayer,l.OGCFeatureLayer,l.OrientedImageryLayer,l.StreamLayer,l.WFSLayer],s=_(e.layer,r);if(!s)throw new b("heatmap-renderer:invalid-parameters","'layer' must be one of these types: "+j(r).join(", "));e.layer=s;const n=e.signal!=null?{signal:e.signal}:null;await s.load(n);const t=await k({field:e.field}),u=Z(s,t,"heatmap-renderer:invalid-parameters");if(u)throw u;return e}async function pe(a){let e=a.scheme,r=null,s=null;const n=await Y(a.basemap,a.view);if(r=n.basemapId!=null?n.basemapId:null,s=n.basemapTheme!=null?n.basemapTheme:null,e)return{scheme:O(e),basemapId:r,basemapTheme:s};const t=ee({basemapTheme:s});return t&&(e=t.primaryScheme,r=t.basemapId,s=t.basemapTheme),{scheme:e,basemapId:r,basemapTheme:s}}async function de(a,e){const{field:r,basemap:s,radius:n,fadeToTransparent:t,heatmapScheme:u,view:p}=e,{scheme:o,basemapId:i,basemapTheme:m}=await pe({basemap:s,scheme:u,view:p}),c=o.colors,R=c.length,T=a.min==null,C=T?[0,.04]:[a.min,a.max];let L;const V=e.fadeRatio??0,$=e.maxRatio??0,g=e.minRatio??0,E=($-g)/(R-1),d=c[0],S=t?g:D,v=[new f({ratio:0,color:new q([d.r,d.g,d.b,0])}),new f({ratio:D,color:new q([d.r,d.g,d.b,0])}),new f({ratio:S,color:new q([d.r,d.g,d.b,S])})];return H(c,R).forEach((B,N)=>{const G=g+E*N;v.push(new f({ratio:G,color:B}))}),t&&(ye(v,V),L=new K({fadeRatio:V})),{renderer:new X({authoringInfo:L,radius:n,colorStops:v,field:r,minDensity:C[0],maxDensity:C[1]}),statistics:a,defaultValuesUsed:T,scheme:O(o),basemapId:i,basemapTheme:m}}function ye(a,e){const r=10*(1-e)+1,s=a.length-3,n=a[2].color.a;a.forEach((t,u)=>{if(u<=2)return;const{color:p}=t,o=(u-3)/s;p.a=e===0?1:Math.min(Math.max(o*r+o+n,n),1)})}async function he(a){const e=await ue(a);return de(e.statistics??await ce({layer:e.layer,field:e.field,radius:e.radius,view:e.view,signal:e.signal}),e)}const fe=new W({baseURL:"/data"}),we=()=>fe.request({method:"GET",url:"/point1.json"}).then(a=>a[0]),Ge=ae({__name:"index",setup(a){const e=I(),r=I([]),s=()=>{we().then(o=>{r.value=o.centerPoints.map((i,m)=>new ie({geometry:new oe({longitude:i.centerPoint[0],latitude:i.centerPoint[1]}),attributes:{probabilityDensity:i.probabilityDensity,ranking:i.ranking,ObjectID:m}}))})};s();const n=o=>{const{result:i}=o;i&&console.log(i)},t=async o=>{const i=o.layer,m=o.view;await i.when(),m.goTo(r.value);const c=await he({layer:i,view:m,field:"probabilityDensity"});console.log(c),e.value=c.renderer},u=()=>{s()},p=()=>{r.value=[]};return(o,i)=>{const m=te("ElButton");return re(),ne(w(P),null,{before:y(()=>[se("p",null,[h(m,{onClick:i[0]||(i[0]=c=>u())},{default:y(()=>[x("getTestData")]),_:1}),h(m,{onClick:p},{default:y(()=>[x("清空")]),_:1})])]),default:y(()=>[h(w(U),{type:"img_w",spatialReference:{wkid:3857}}),h(w(J),null,{default:y(({spatialReference:c})=>[h(w(A),{spatialReference:c,renderer:e.value,source:r.value,fields:[{name:"ObjectID",type:"oid"},{name:"probabilityDensity",type:"double"},{name:"ranking",type:"double"}],"geometry-type":"point","object-id-field":"ObjectID",cursor:"pointer",onClick:n,onChange:t},null,8,["spatialReference","renderer","source"])]),_:1})]),_:1})}}});export{Ge as default};
