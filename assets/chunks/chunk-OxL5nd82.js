import{g2 as A,q as D,g3 as d,d1 as c,dT as v,g4 as h,g5 as y,g6 as $,g7 as M,g8 as I}from"./chunk-CGsGeN7j.js";import{u as w,c as l,i as O,f as S}from"./chunk-BwDmGiFs.js";import"./chunk-ByM7454y.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */import"./chunk-DDNWrLi0.js";class _{transform(t){const o=this._transform(t),r=[o.points.buffer,o.rgb.buffer];o.pointIdFilterMap!=null&&r.push(o.pointIdFilterMap.buffer);for(const a of o.attributes)"buffer"in a.values&&A(a.values.buffer)&&a.values.buffer!==o.rgb.buffer&&r.push(a.values.buffer);return Promise.resolve({result:o,transferList:r})}_transform(t){const o=w(t.schema,t.geometryBuffer);let r=o.length/3,a=null;const p=new Array,m=l(t.primaryAttributeData,o,r);t.primaryAttributeData!=null&&m&&p.push({attributeInfo:t.primaryAttributeData.attributeInfo,values:m});const e=l(t.modulationAttributeData,o,r);t.modulationAttributeData!=null&&e&&p.push({attributeInfo:t.modulationAttributeData.attributeInfo,values:e});let i=O(t.rendererInfo,m,e,r);if(t.filterInfo&&t.filterInfo.length>0&&t.filterAttributesData!=null){const s=t.filterAttributesData.filter(D).map(f=>{const u=l(f,o,r),b={attributeInfo:f.attributeInfo,values:u};return p.push(b),b});a=new Uint32Array(r),r=S(o,i,a,t.filterInfo,s)}for(const s of t.userAttributesData){const f=l(s,o,r);p.push({attributeInfo:s.attributeInfo,values:f})}3*r<i.length&&(i=new Uint8Array(i.buffer.slice(0,3*r))),this._applyElevationOffsetInPlace(o,r,t.elevationOffset);const n=this._transformCoordinates(o,r,d.fromData(t.obbData),c.fromJSON(t.inSR),c.fromJSON(t.outSR));return{obbData:t.obbData,points:n,rgb:i,attributes:p,pointIdFilterMap:a}}_transformCoordinates(t,o,r,a,p){if(!v(t,a,0,t,p,0,o))throw new Error("Can't reproject");const m=h(r.center),e=I(),i=I(),n=h(r.halfSize);y(g,r.quaternion);const s=new Float32Array(3*o);for(let f=0;f<o;f++){let u=3*f;e[0]=t[u]-m[0],e[1]=t[u+1]-m[1],e[2]=t[u+2]-m[2],$(i,e,g),n[0]=Math.max(n[0],Math.abs(i[0])),n[1]=Math.max(n[1],Math.abs(i[1])),n[2]=Math.max(n[2],Math.abs(i[2])),s[u++]=e[0],s[u++]=e[1],s[u]=e[2]}return r.halfSize=n,s}_applyElevationOffsetInPlace(t,o,r){if(r!==0)for(let a=0;a<o;a++)t[3*a+2]+=r}}const g=M();function lt(){return new _}export{lt as default};
