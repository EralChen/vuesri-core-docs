import{b as S,c as j,d as z,e as B,j as d,F as k,l as L,k as I,u as m,m as p,L as V,s as u,n as q}from"./chunk-CMhy9c9G.js";import{P as C,y as N,w as x,$ as H,d as Q,v as W,p as O,f as X,I as R,m as T}from"./chunk-DN1dNLsK.js";import{t as Z,i as aa}from"./chunk-C5OhRf_W.js";import"./chunk-ByM7454y.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */const w="Feature Service",v="feature-layer-utils",ta=`${v}-save`,ea=`${v}-save-as`,y=`${v}-saveall`,f=`${v}-saveall-as`;function $(a){return{isValid:V(a)&&(!("dynamicDataSource"in a)||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(a){const t=[],e=[];for(const{layer:r,layerJSON:i}of a)r.isTable?e.push(i):t.push(i);return{layers:t,tables:e}}function M(a){return g([a])}async function D(a,t){return/\/\d+\/?$/.test(a.url)?M(t[0]):F(t,a)}async function F(a,t){if(a.reverse(),!t)return g(a);const e=await ra(t,a);for(const r of a)J(r.layer,r.layerJSON,e);return ia(e,a),e}async function ra(a,t){let e=await a.fetchData("json");if(oa(e))return e;e||={},na(e);const{layer:{url:r,customParameters:i,apiKey:n}}=t[0];return await sa(e,{url:r??"",customParameters:i,apiKey:n},t.map(o=>o.layer.layerId)),e}function oa(a){return!!(a&&Array.isArray(a.layers)&&Array.isArray(a.tables))}function na(a){a.layers||=[],a.tables||=[]}function ia(a,t){const e=[],r=[];for(const{layer:i}of t){const{isTable:n,layerId:o}=i;n?r.push(o):e.push(o)}A(a.layers,e),A(a.tables,r)}function A(a,t){if(a.length<2)return;const e=[];for(const{id:r}of a)e.push(r);j(e.sort(E),t.slice().sort(E))&&a.sort((r,i)=>{const n=t.indexOf(r.id),o=t.indexOf(i.id);return n<o?-1:n>o?1:0})}function E(a,t){return a<t?-1:a>t?1:0}async function sa(a,t,e){const{url:r,customParameters:i,apiKey:n}=t,{serviceJSON:o,layersJSON:s}=await Z(r,{customParameters:i,apiKey:n}),l=b(a.layers,o.layers,e),c=b(a.tables,o.tables,e);a.layers=l.itemResources,a.tables=c.itemResources;const h=[...l.added,...c.added],K=s?[...s.layers,...s.tables]:[];await la(a,h,r,K)}function b(a,t,e){const r=z(a,t,(n,o)=>n.id===o.id);a=a.filter(n=>!r.removed.some(o=>o.id===n.id));const i=r.added;return i.forEach(({id:n})=>{a.push({id:n})}),{itemResources:a,added:i.filter(({id:n})=>!e.includes(n))}}async function la(a,t,e,r){const i=await ca(t),n=t.map(({id:o,type:s})=>new(i.get(s))({url:e,layerId:o,sourceJSON:r.find(({id:l})=>l===o)}));await Promise.allSettled(n.map(o=>o.load())),n.forEach(o=>{const{layerId:s,loaded:l,defaultPopupTemplate:c}=o;if(!l||c==null)return;const h={id:s,popupInfo:c.toJSON()};o.operationalLayerType!=="ArcGISFeatureLayer"&&(h.layerType=o.operationalLayerType),J(o,h,a)})}async function ca(a){const t=[];a.forEach(({type:i})=>{const n=aa(i),o=B[n];t.push(o())});const e=await Promise.all(t),r=new Map;return a.forEach(({type:i},n)=>{r.set(i,e[n])}),r}function J(a,t,e){a.isTable?P(e.tables,t):P(e.layers,t)}function P(a,t){const e=a.findIndex(({id:r})=>r===t.id);e===-1?a.push(t):a[e]=t}function Y(a,t){if(!a.length)throw new u(`${t}:missing-parameters`,"'layers' array should contain at least one feature layer")}function pa(a,t){const e=a.map(r=>r.portalItem.id);if(new Set(e).size>1)throw new u(`${t}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function _(a,t){const e=a.map(r=>r.layerId);if(new Set(e).size!==e.length)throw new u(`${t}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function ua(a){Y(a,y),await Promise.all(a.map(t=>t.load()));for(const t of a)O(t,y,$),X({layer:t,itemType:w,errorNamePrefix:y});pa(a,y),_(a,y)}function U(a,t){const e=a.layers.some(r=>r.layerType==="OrientedImageryLayer");m(t,p.ORIENTED_IMAGERY_LAYER,e)}function G(a,t){const e=a.some(r=>r.type==="oriented-imagery");m(t,p.ORIENTED_IMAGERY_LAYER,e)}async function ma(a,t,e){U(e,t)}async function ya(a,t){const{url:e,layerId:r,title:i,fullExtent:n,isTable:o}=a,s=d(e);t.url=(s?.serverType==="FeatureServer"?e:`${e}/${r}`)??null,t.title||=i,t.extent=null,o||n==null||(t.extent=await L(n)),I(t,p.METADATA),I(t,p.MULTI_LAYER),q(t,p.SINGLE_LAYER),m(t,p.TABLE,o),G([a],t)}function fa(a,t){for(const n of a){const o=n.parsedUrl.path,s=d(o);if(!s?.url.path)throw new u(`${t}:invalid-parameters`,T(n,`has unsupported url pattern: ${o}`),{layer:n});const c=s?.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new u(`${t}:invalid-parameters`,T(n,`has unsupported server type: ${c}`),{layer:n});if(c==="MapServer"&&a.length>1)throw new u(`${t}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const e=d(a[0].parsedUrl.path),r=e?.url.path;if(!a.every(n=>d(n.parsedUrl.path)?.url.path===r))throw new u(`${t}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function da(a){Y(a,f),await Promise.all(a.map(t=>t.load()));for(const t of a)O(t,f,$);fa(a,f),_(a,f)}function ha(a,t){U(t,a),R(a)}async function wa(a,t){let e=0,r=0;for(const{isTable:o}of t)o?r++:e++;const i=t[0].parsedUrl.path,n=d(i);if(a.url=n?.serverType==="FeatureServer"?n.url.path:i,a.title||=n.title,a.extent=null,e>0){const o=t.map(s=>s.fullExtent).filter(k).reduce((s,l)=>s.clone().union(l));o&&(a.extent=await L(o))}I(a,p.METADATA),m(a,p.MULTI_LAYER,t.length>1),m(a,p.SINGLE_LAYER,t.length===1),m(a,p.TABLE,r>0&&e===0),G(t,a),R(a)}async function at(a,t){return C({layer:a,itemType:w,validateLayer:$,createItemData:(e,r)=>D(r,[e]),errorNamePrefix:ta,setItemProperties:ma},t)}async function tt(a,t){await ua(a);const e=a[0].portalItem,r=N(e),i=await Promise.all(a.map(o=>x(o,r,t))),n=await D(e,a.map((o,s)=>({layer:o,layerJSON:i[s]})));return ha(e,n),await e.update({data:n}),await Promise.all(a.slice(1).map(o=>o.portalItem.reload())),S(r),e.clone()}async function et(a,t,e){return H({layer:a,itemType:w,validateLayer:$,createItemData:(r,i)=>Promise.resolve(M(r)),errorNamePrefix:ea,newItem:t,setItemProperties:ya},e)}async function rt(a,t,e){await da(a);const r=Q({itemType:w,errorNamePrefix:f,newItem:t}),i=N(r),n=await Promise.all(a.map(s=>x(s,i,e))),o=await F(a.map((s,l)=>({layer:s,layerJSON:n[l]})));await wa(r,a),await W(r,o,e);for(const s of a)s.portalItem=r.clone();return S(i),r}export{at as save,tt as saveAll,rt as saveAllAs,et as saveAs};
