import{u as v}from"./chunk-Dc5RCiI0.js";import{gJ as f,gO as g,gN as w,lo as y,pu as V,h1 as _}from"./chunk-CMhy9c9G.js";import{T as H}from"./chunk-Ch0SDxT-.js";function S(){const o=f("vaParentView");if(!o)throw new Error("No parent view provided");return o}class m extends H{constructor(r,t){super(),this.originView=r,this.targetView=t}add(){this.handler||(this.handler=this.originView.watch("viewpoint",r=>{this.targetView.viewpoint=r}),this.removeHandler=()=>{this.handler?.remove(),this.handler=null})}}const P=g({__name:"index",props:{syncKey:{type:String,default:"__va_derived_view_sync_init__"},synchronization:{type:String,default:"one-way"}},setup(o){const r=o,t=r.syncKey,e=S();e[t]||(e[t]=new Map);const n=v(),s=new m(e,n),a=new m(n,e);w(()=>{s.remove(),a.remove()});const l=y(()=>r.synchronization==="two-way");V(()=>{n.when(()=>{e.viewpoint&&(n.viewpoint=e.viewpoint)})}),d();function d(){if(a.remove(),s.handler||(s.add(),!l.value))return;const i=n.watch("interacting, animation",c=>{c&&(s.remove(),e[t].forEach((h,p)=>{p!==n&&h()}),i.remove())})}e[t].set(n,()=>d()),w(()=>{e[t].delete(n)});const u=e.watch("interacting, animation",i=>{i&&d()});if(w(()=>{u.remove()}),l.value){const i=n.watch("interacting, animation",c=>{if(!c||a.handler)return;a.add();const h=e.watch("interacting, animation",p=>{p&&(a.remove(),h.remove())})});w(()=>{i.remove()})}return(i,c)=>_(i.$slots,"default")}});export{P as _};
