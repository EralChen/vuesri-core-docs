import{bY as Pe,m3 as le,oA as N,iD as U,eT as T,nm as Ee,kF as Oe,nw as Ue,E as Ae,oB as Ie,eF as Fe,s as X,oC as Re,am as ce,a0 as Ve,oD as D,oE as de,ag as he,e0 as Se,lp as ue,cj as He,e8 as De,oF as Le,oG as je,oH as Be,oI as ke,eU as me,oJ as Ge,oK as Y,oL as Ne,oM as $e,bq as K,mR as pe,dQ as fe,oN as ge,oO as ze,js as We,eN as L,oP as Je,bt as qe,eb as Qe,oQ as Xe,oR as Ye,oS as ye,eS as Ke,oh as Ze,oj as et,ol as tt,on as Z,om as st,oq as it,eO as j,os as rt,oT as ot,oU as at,oV as be,oW as _e,A as we,a1 as B,a2 as ee,a4 as nt,bZ as lt,hD as ve}from"./chunk-YzRi88Dj.js";import{x as ct,f as dt}from"./chunk-DULDps7H.js";import{r as M,a as te,S as k,N as E,e as f,m as ht,d as ut,g as se,t as C,n as ie,i as F}from"./chunk-vPx4somd.js";import{n as mt}from"./chunk-vB7g5hVZ.js";import{s as pt}from"./chunk-DNVxKvLf.js";import"./chunk-ByM7454y.js";/* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              *//* empty css              */class ft extends Pe{constructor(e,c,a,o,r,u,p){super(e,0,0,0,c),this.nodesCached=a,this.vboMB=o,this.textureMB=r,this.vboMBCached=u,this.textureMBCached=p}}const gt={[M.Points]:null,[M.Lines]:null,[M.LineStrip]:null,[M.Triangles]:le.TRIANGLES,[M.TriangleStrip]:le.TRIANGLE_STRIP,[M.NotSet]:null},xe={[te.Opaque]:N.Opaque,[te.Mask]:N.Mask,[te.Blend]:N.Blend},yt={[k.Back]:U.Back,[k.Front]:U.Front,[k.None]:U.None,[k.NotSet]:U.Back},bt={[E.WrapYBit]:{s:T.CLAMP_TO_EDGE,t:T.REPEAT},[E.WrapXBit]:{s:T.REPEAT,t:T.CLAMP_TO_EDGE},[E.WrapXy]:{s:T.REPEAT,t:T.REPEAT},[E.None]:{s:T.CLAMP_TO_EDGE,t:T.CLAMP_TO_EDGE},[E.NotSet]:{s:T.CLAMP_TO_EDGE,t:T.CLAMP_TO_EDGE}},_t={[f.U8]:1,[f.I8]:1,[f.U16]:2,[f.I16]:2,[f.U32]:4,[f.I32]:4,[f.F32]:4,[f.F64]:8,[f.Utf8String]:1,[f.NotSet]:1};class wt{constructor(e){this.layerUid=[],this.type=Ee.TILES3D,this.slicePlaneEnabled=!1,this.isGround=!0,this.layerView=e,this.layerUid.push(e.layer.uid)}intersect(e,c,a,o){const r=e.results,u=e.options.store===Oe.ALL;if(e.options.filteredLayerUids.includes(this.layerView.layer.uid))return;const p=this.layerView.view._stage.renderView.componentObjectCollection;this.layerView.objects.forEach(y=>{y.visible&&y.intersectionGeometry&&p.intersect(y,a,o,e.tolerance,null,(_,m,h,d)=>{if(m>=0){if(c!=null&&!c(a,o,m))return;const n=i=>{const l=new Ie(this.layerView.layer.uid,()=>this._createTiles3DGraphic(this.layerView.layer,{}));i.set(this.type,l,m,h)};if(this.isGround&&(r.ground.dist==null||m<r.ground.dist)&&n(r.ground),e.options.isFiltered)return;if((r.min.dist==null||m<r.min.dist)&&n(r.min),(r.max.dist==null||m>r.max.dist)&&n(r.max),u){const i=Ue(e.ray);n(i),e.results.all.push(i)}}})})}_createTiles3DGraphic(e,c){return new Ae({layer:e,sourceLayer:e,attributes:c})}}var g;(function(t){t[t.API=1]="API",t[t.VerboseAPI=2]="VerboseAPI",t[t.Error=3]="Error"})(g||(g={}));class vt{constructor(){this.handle=0,this.isVisible=!1,this.components=[],this.texMemoryUsage=0,this.vboMemoryUsage=0,this.cpuMemoryUsage=0,this.textures=[]}totalMemory(){return this.texMemoryUsage+this.vboMemoryUsage+this.cpuMemoryUsage}}function G(t){return Math.round(t/1048.576)/1e3}let O=class extends mt(lt){constructor(){super(...arguments),this.type="integrated-mesh-3dtiles",this._visibleGeometryChangedSchedulerHandle=null,this._wasmLayerId=-1,this.ignoresMemoryFactor=!1,this.drapeTargetType=Fe.WithoutRasterImage,this._lyrHandleToObjects=new Map,this._initialCullFace=new Map,this._suspendedHandle=null,this._dbgFlags=new Set}initialize(){if(this._dbgFlags.add(g.Error),this._dbg(g.VerboseAPI,"Tiles3DLayerView3D initialize() called"),!this._canProjectWithoutEngine())throw new X("layerview:spatial-reference-incompatible","The spatial reference of this scene layer is incompatible with the spatial reference of the view",{});const t=Re(this).then(e=>{this._intersectionHandler=new wt(this),this.view.sceneIntersectionHelper.addIntersectionHandler(this._intersectionHandler),this._updatingHandles.add(()=>this.slicePlaneEnabled,a=>this._slicePlaneEnabledChange(a)),this._elevationProvider=new ct({view:this.view,layerElevationSource:this,intersectionHandler:this._intersectionHandler}),this.view.elevationProvider.register("im",this._elevationProvider),this.view.basemapTerrain.overlayManager.registerDrapeTarget(this),this._wasmLayerId=e;const c=this.view.resourceController.memoryController.newCache(`t3d-${this.uid}`,a=>this._onRemoveFromCache(a));this._memCache=c,this._suspendedHandle=ce(()=>this.suspended,a=>{const o=D(this.view);o&&o.setEnabled(this,!a)},Ve),this.addHandles([ce(()=>this.layer.elevationInfo,a=>this._elevationInfoChanged(a))])}).catch(e=>{if(de(this),this._wasmLayerId=-1,e===ht)throw new X("tiles3d:addLayer-failure","The 3d tiles layer description was invalid.",{});if(e===ut)throw new X("tiles3d:addLayer-failure","The 3d tiles layer web assembly module failed to download.",{})});this.addResolvingPromise(t)}destroy(){this._dbg(g.VerboseAPI,"Tiles3DLayerView3D destroy() called"),de(this),this._suspendedHandle&&(this._suspendedHandle.remove(),this._suspendedHandle=null),this._intersectionHandler&&(this.view.sceneIntersectionHelper.removeIntersectionHandler(this._intersectionHandler),this._intersectionHandler=null),this._elevationProvider&&(this._elevationProvider.objectsChanged(this._obbs),this.view.elevationProvider.unregister(this._elevationProvider),this._elevationProvider=null),this.view.basemapTerrain.overlayManager.unregisterDrapeTarget(this),this._lyrHandleToObjects.forEach(t=>this.freeObject(t)),this._lyrHandleToObjects.clear(),this._initialCullFace.clear(),this._memCache=he(this._memCache),this._updatingHandles=he(this._updatingHandles),this.emit("visible-geometry-changed"),this._visibleGeometryChangedSchedulerHandle&&(this._visibleGeometryChangedSchedulerHandle.remove(),this._visibleGeometryChangedSchedulerHandle=null)}_visibleGeometryChanged(){this._visibleGeometryChangedSchedulerHandle==null&&(this._visibleGeometryChangedSchedulerHandle=Se(()=>{this.emit("visible-geometry-changed"),this._visibleGeometryChangedSchedulerHandle=null}))}_slicePlaneEnabledChange(t){this._intersectionHandler&&(this._intersectionHandler.slicePlaneEnabled=t),this.objects.forEach(e=>{const c=this._collection.getMaterial(e);c.commonMaterialParameters.hasSlicePlane=t,c.commonMaterialParameters.cullFace=t?U.None:this._initialCullFace.get(e)})}_elevationInfoChanged(t){const e=t?.offset??0,c=t?.unit?ue(t?.unit):1,a=D(this.view);a&&a.setLayerOffset(this,e*c)}get _obbs(){return this.objects.map(t=>this._collection.getComponentObb(t))}get wasmLayerId(){return this._wasmLayerId}get usedMemory(){let t=0;return this._lyrHandleToObjects.forEach(e=>{e.isVisible&&(t+=e.totalMemory())}),t}get unloadedMemory(){let t=0;return this._lyrHandleToObjects.forEach(e=>{e.isVisible||(t+=e.totalMemory())}),t}get performanceInfo(){let t=0,e=0,c=0,a=0,o=0,r=0;return this._lyrHandleToObjects.forEach(u=>{u.isVisible?(t+=u.texMemoryUsage,e+=u.vboMemoryUsage,o++):(c+=u.texMemoryUsage,a+=u.vboMemoryUsage,r++)}),new ft(this.usedMemory,o,r,G(e),G(t),G(a),G(c))}_canProjectWithoutEngine(){if(this.view.state.viewingMode===He.Local){const t=this.view.renderSpatialReference?.isWebMercator?3857:this.view.renderSpatialReference?.wkid??-1;if(t!==3857&&t!==32662)return!1}return!0}get _stage(){return this.view._stage}get _collection(){return this._stage.renderView.componentObjectCollection}get elevationOffset(){return(this.layer.elevationInfo?.offset??0)*(this.layer.elevationInfo?.unit?ue(this.layer.elevationInfo.unit):1)}get elevationRange(){const t=this.fullExtent;return t?.zmin&&t?.zmax?new De(t.zmin,t.zmax):null}getElevationRange(t){return null}get fullExtent(){return this.layer.fullExtent}get objects(){return Array.from(this._lyrHandleToObjects.values()).reduce((t,e)=>t.concat(e.components),new Array)}isUpdating(){const t=D(this.view);return!(this._wasmLayerId<0||t==null)&&t.isUpdating(this._wasmLayerId)}updatingFlagChanged(){this.notifyChange("updating")}async createRenderable(t){const e=t.meshData;if(e.data==null)throw new Error("meshData.data undefined");if(e.desc=JSON.parse(e.desc),e.desc==null)throw new Error("meshData.desc undefined");const c=Le(e.desc.origin),a=new Array,o=new Map,r=new vt;r.handle=t.handle,this._lyrHandleToObjects.set(t.handle,r);const u=this.view.basemapTerrain.spatialReference;let p,y;if(this.view.viewingMode==="global"){const n=ve();je(Be,c,n,u),p=ke(me(),n),y=Ge(me(),p)}else p=Y,y=Y;const _=ve();Ne(_,_,c);const m=$e(K(),_);let h=null;const d=K();for(let n=0;n<e.desc.prims.length;n++){const i=e.desc.prims[n];if(i.ptype!==M.Lines||e.data==null)continue;const{positionView:l,positionAttr:b,indicesView:P}=this.getBufferViews(i,e.data.buffer,p,!1);b!=null&&l!=null&&P!=null&&(h=pe(b),fe(d,h.center,c),h.center=d)}for(let n=0;n<e.desc.prims.length;n++){const i=e.desc.prims[n];if(this._dbg(g.VerboseAPI,JSON.stringify(i)),i.ptype===M.Lines)continue;if(gt[i.ptype]==null||e.data==null){this._dbg(g.VerboseAPI,"[Unsupported Feature] Unsupported primitive mode ("+i.ptype+"). Skipping primitive.");continue}const l=e.desc?.materials&&i.materialId!=null?e.desc.materials[i.materialId]:null,b=l!=null?l.lightingModel:se.Unlit,P=b!==se.Unlit,{positionView:v,positionAttr:w,normalsView:$,normalsAttr:z,colorAttr:R,texCoord0Attr:V,indicesView:A}=this.getBufferViews(i,e.data.buffer,p,P);if(w==null||v==null||A==null)continue;const re={colors:R!=null,textureCoordinates:V!=null?ge.Default:ge.None,hasNormals:$!=null,needsNormals:P},Te=w.data.length/w.size,W=(s,x)=>!s||s.data.length/s.size===Te||(this._dbg(g.Error,`${x} !== numPos. Skipping primitive.`),!1);if(!W(V,"numTexcoord")||!W(R,"numColors")||!W(z,"normals"))continue;const oe=ze(re);let I;if(h!=null?I=h.clone():(I=pe(w),fe(d,I.center,c),I.center=d),p!==Y)for(let s=0;s<v.count;s++)v.getVec(s,d),We(d,d,p),v.setVec(s,d);const J=oe.createBuffer(w.data.length),S=new Map([[L.POSITION,w]]);V!=null&&S.set(L.UV0,V),R!=null&&S.set(L.COLOR,R),z!=null&&S.set(L.NORMALCOMPRESSED,z),S.forEach((s,x)=>{s!=null&&Je(x,s,null,null,J,0)});const Ce=new Uint32Array([0,A.typedBuffer.length]),Me={vertices:{data:J.buffer,count:J.byteLength/oe.stride,layoutParameters:re},positionData:{positions:v.typedBuffer,indices:A.typedBuffer},indices:A.typedBuffer,componentOffsets:Ce};r.cpuMemoryUsage+=v.count,r.cpuMemoryUsage+=A.count;const ae=this.view.renderSpatialReference,q=K(),Q=[1,1,1];dt(m,ae,Q,u)||this._dbg(g.Error,"Unsupported coordinate system for IM overlay"),qe(m,ae,q,u);const H=this._collection.createObject({toMapSpace:Qe(q[0],q[1],Q[0],Q[1]),geometry:Me,obb:I,transform:{position:m,rotationScale:y}});l&&this._collection.updateMaterial(H,s=>{s.baseColor=l.baseColorFactor,s.usePBR=b===se.Pbr,s.hasParametersFromSource=!1,s.baseColorTexture=this._getTexture(l.baseColorTex,e,o),s.usePBR&&(s.mrrFactors=[l.metallicFactor,l.roughnessFactor,0],s.emissiveFactor=l.emissiveFactor??[0,0,0],s.metallicRoughnessTexture=this._getTexture(l.metalTex,e,o),s.emissionTexture=this._getTexture(l.emissiveTex,e,o),s.occlusionTexture=this._getTexture(l.occlusionTex,e,o),s.normalTexture=this._getTexture(l.normalTex,e,o)),s.objectOpacity=0,s.alphaDiscardMode=N.Mask;const x=[];s.baseColorTexture&&x.push(s.baseColorTexture.loadPromise),s.usePBR&&s.metallicRoughnessTexture&&x.push(s.metallicRoughnessTexture.loadPromise),s.usePBR&&s.emissionTexture&&x.push(s.emissionTexture.loadPromise),s.usePBR&&s.occlusionTexture&&x.push(s.occlusionTexture.loadPromise),s.usePBR&&s.normalTexture&&x.push(s.normalTexture.loadPromise);const ne=Promise.all(x);a.push(ne),ne.then(()=>{s.alphaDiscardMode=xe[l.alphaMode],s.objectOpacity=1,r.texMemoryUsage+=s.baseColorTexture?.glTexture?.usedMemory||0,s.usePBR&&(r.texMemoryUsage+=s.metallicRoughnessTexture?.glTexture?.usedMemory||0,r.texMemoryUsage+=s.emissionTexture?.glTexture?.usedMemory||0,r.texMemoryUsage+=s.occlusionTexture?.glTexture?.usedMemory||0,r.texMemoryUsage+=s.normalTexture?.glTexture?.usedMemory||0)}),s.commonMaterialParameters.doubleSided=l.isDoubleSided,s.commonMaterialParameters.cullFace=l.faceCulling?yt[l.faceCulling]:U.Back,this._initialCullFace.set(H,s.commonMaterialParameters.cullFace),s.commonMaterialParameters.hasSlicePlane=this.slicePlaneEnabled,s.componentParameters.castShadows=Xe.All,s.textureAlphaCutoff=l.alphaCutoff??.1,s.alphaDiscardMode=xe[l.alphaMode],s.isIntegratedMesh=!0,s.polygonOffsetEnabled=!1,s.hasOccludees=!1,s.ellipsoidMode=Ye(this.view.spatialReference)}),r.components.push(H),r.vboMemoryUsage+=this._collection.getObjectGPUMemoryUsage(H)}if(await Promise.all(a),o.forEach(n=>{r.textures.push(n)}),!this._memCache)throw new Error("no memCache");return this._memCache.put(`${r.handle}`,r,r.totalMemory()),{memUsageBytes:r.totalMemory()}}freeRenderable(t){const e=this._lyrHandleToObjects.get(t);e&&(this.freeObject(e),this._lyrHandleToObjects.delete(t))}freeObject(t){this._memCache&&this._memCache.pop(`${t.handle}`),t.components.forEach(e=>{t.textures.forEach(c=>{this._stage.remove(c)}),this._collection.destroyObject(e),this._initialCullFace.delete(e)})}setRenderableVisibility(t,e,c){if(this._memCache){for(let a=0;a<c;++a){const o=t[a],r=e[a];if(!r)continue;const u=this._lyrHandleToObjects.get(o);u&&(this._visibleGeometryChanged(),u.isVisible=r,u.components.forEach(p=>{this._collection.setObjectVisibility(p,r),this._elevationProvider.objectChanged(this._collection.getComponentObb(p))}),this._memCache.pop(`${o}`))}for(let a=0;a<c;++a){const o=t[a],r=e[a];if(r)continue;const u=this._lyrHandleToObjects.get(o);u&&(this._visibleGeometryChanged(),u.isVisible=r,u.components.forEach(p=>{this._collection.setObjectVisibility(p,r),this._elevationProvider.objectChanged(this._collection.getComponentObb(p))}),this._memCache.put(`${o}`,u,u.totalMemory()))}}}_getTexture(t,e,c){let a=null;if(t&&e.desc?.images&&e.data?.buffer){const o=e.desc.images[t?.imageId];if(a=c.get(o),!a&&o){const r=this._stage.renderView.renderingContext.parameters.maxMaxAnisotropy,u=r>1,p=bt[t.wrapMode??E.None];let y=o.alpha?4:3;const _=new Uint8Array(e.data.buffer,o.data.byteOffset,o.data.byteCount);let m=null,h=null,d=null;switch(o.format){case C.Raw:o.pixelFormat===ie.R8?(m=_.buffer,y=1,h=""):o.pixelFormat===ie.Rgb8?(m=_.buffer,y=3,h=""):o.pixelFormat===ie.Rgba8&&(m=_.buffer,y=4,h="");break;case C.Dxt1:m=_.buffer,y=3,h=ye.DDS_ENCODING;break;case C.Dxt5:m=_.buffer,y=4,h=ye.DDS_ENCODING;break;case C.Png:h="image/png",d=document.createElement("img");break;case C.Jpeg:h="image/jpeg",d=document.createElement("img");break;case C.Etc2:h="image/ktx",d=document.createElement("img");break;case C.Astc:this._dbg(g.Error,"Astc texture not supported");break;case C.Pvrtc:this._dbg(g.Error,"Pvrtc texture not supported")}if(d&&h){const n=new Blob([_],{type:h});d.src=URL.createObjectURL(n),m=d}m&&h!=null&&(a=new Ke(m,{mipmap:u,maxAnisotropy:r,encoding:h,wrap:p,components:y,noUnpackFlip:!0,width:o.mip0Width,height:o.mip0Height}),this._stage.add(a),c.set(o,a))}}return a?new pt(this.view._stage.renderView.textureRepository,a.id):null}getBufferViews(t,e,c,a){let o,r,u,p,y,_,m,h=null;for(let d=0;d<t.atrbs.length;d++){const n=t.atrbs[d],i=n.view,l=void 0,b=i.byteOffset+i.byteCount,P=i.byteCount/_t[i.type],v=[...Array(P).keys()].map(w=>w);try{switch(n.sem){case F.Position:i.ncomp!==3||i.type!==f.F32?this._dbg(g.Error,"[Unsupported Feature] Unsupported view for Position ("+i+")"):(o=new Z(e,i.byteOffset,l,b),r=new j(o.typedBuffer,v,3));break;case F.Normal:if(i.ncomp!==3||i.type!==f.F32)this._dbg(g.Error,"[Unsupported Feature] Unsupported view for Normal ("+i+")");else if(a){const w=new Z(e,i.byteOffset,l,b),$=ot(w.typedBuffer,c);y=new at($),_=new j(y.typedBuffer,v,2)}break;case F.TexCoord:i.ncomp!==2||i.type!==f.F32?this._dbg(g.Error,"[Unsupported Feature] Unsupported view for Texcoord ("+i+")"):p===void 0&&(p=new j(new rt(e,i.byteOffset,l,b).typedBuffer,v,2));break;case F.Color:i.ncomp===4?(i.type===f.F32&&(h=new Ze(e,i.byteOffset,l,b)),i.type===f.U8&&(h=new et(e,i.byteOffset,l,b)),i.type===f.U16&&(h=new tt(e,i.byteOffset,l,b))):i.ncomp===3&&(i.type===f.F32&&(h=new Z(e,i.byteOffset,l,b)),i.type===f.U8&&(h=new st(e,i.byteOffset,l,b)),i.type===f.U16&&(h=new it(e,i.byteOffset,l,b))),h==null?this._dbg(g.VerboseAPI,"[Unsupported Feature] Unsupported view for Color ("+i+")"):u=new j(h.typedBuffer,v,i.ncomp);break;case F.FeatureIndex:break;default:this._dbg(g.VerboseAPI,"[Unsupported Feature] Unsupported semantic ("+n.sem+"). Skipping vertex attribute.")}}catch(w){this._dbg(g.VerboseAPI,"Error Creating buffer ("+w+"). Skipping vertex attribute.")}}if(t.index){const d=t.index.view,n=void 0,i=d.byteOffset+d.byteCount;switch(t.index.view.type){case f.U16:m=new _e(e,d.byteOffset,n,i);break;case f.U32:m=new be(e,d.byteOffset,n,i);break;case f.U8:default:this._dbg(g.Error,"[Unsupported Feature] index type not supported ("+d.type+").")}}if(m==null&&o!=null){const d=o.count;if(d<65535){const n=new Uint16Array(d);m=new _e(n)}else{const n=new Uint32Array(d);m=new be(n)}for(let n=0;n<d;n++)m.set(n,n)}return{positionView:o,positionAttr:r,colorAttr:u,texCoord0Attr:p,indicesView:m,normalsView:y,normalsAttr:_}}_onRemoveFromCache(t){const e=D(this.view);e&&e.onRenderableEvicted(this,t.handle,t.totalMemory()),this.freeRenderable(t.handle)}_dbg(t,e){this._dbgFlags.has(t)&&(t===g.Error?we.getLogger(this).error(e):we.getLogger(this).warn(e))}};B([ee()],O.prototype,"_visibleGeometryChangedSchedulerHandle",void 0),B([ee()],O.prototype,"layer",void 0),B([ee()],O.prototype,"elevationOffset",null),O=B([nt("esri.views.3d.layers.Tiles3DLayerView3D")],O);const as=O;export{as as default};
